# JVM

### OOM的场景以及解决方案

1、**内存泄漏**：内存泄漏是指程序在使用完内存后未及时释放，导致内存占用不断增加，最终耗尽可用内存。常见的内存泄漏情况包括未关闭数据库连接、未释放资源、循环引用等。

解决方案包括：

- 确保及时释放不再使用的对象和资源，特别是涉及到文件、数据库连接、网络连接等需要手动关闭的资源。
- 使用合适的数据结构和算法，避免不必要的对象创建和持有。
- 使用内存分析工具来检测和识别内存泄漏问题，并进行修复。

2、**内存溢出**：内存溢出是指程序在申请内存时无法获得足够的连续内存空间，导致无法满足内存需求。常见的内存溢出情况包括递归调用导致栈溢出、大对象占用过多内存等。解决方案包括：

- 优化算法和代码，减少内存占用。
- 使用分页或分块的方式处理大对象，避免一次性申请过多内存。
- 增加可用内存的限制或调整JVM的内存参数，如堆内存大小、栈大小等。





### CMS 和 G1 区别

#### CMS收集器：

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实现,在标记清理过程中不会导致用户线程无法定位引用对象。仅作用于老年代收集。它的步骤如下：

1. 初始标记（CMS initial mark）：独占CPU，stop-the-world, 仅标记GCroots能直接关联的对象,速度比较快；
2. 并发标记（CMS concurrent mark）:可以和用户线程并发执行，通过GCRoots Tracing 标记所有可达对象；
3. 重新标记（CMS remark）：独占CPU，stop-the-world, 对并发标记阶段用户线程运行产生的垃圾对象进行标记修正,以及更新逃逸对象；
4. 并发清理（CMS concurrent sweep）：可以和用户线程并发执行，清理在重复标记中被标记为可回收的对象。

#### 优点：

- 支持并发收集.
- 低停顿,因为CMS可以控制将耗时的两个stop-the-world操作保持与用户线程恰当的时机并发执行，并且能保证在短时间执行完成，这样就达到了近似并发的目的.

#### 缺点：

- CMS收集器**对CPU资源非常敏感**, 在并发阶段虽然不会导致用户线程停顿，但是会因为占用了一部分CPU资源，如果在CPU资源不足的情况下应用会有明显的卡顿。
- **无法处理浮动垃圾**：在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收。如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent  Mode Failure’,一旦出现此错误时便会切换到SerialOld收集方式。
- CMS清理后会**产生大量的内存碎片**，当有不足以提供整块连续的空间给新对象/晋升为老年代对象时又会触发FullGC。且在1.9后将其废除。

#### 使用场景

它关注的是垃圾回收最短的停顿时间（低停顿），在老年代并不频繁GC的场景下，是比较适用的。



#### G1收集器

G1收集器的内存结构完全区别于CMS，弱化了CMS原有的分代模型（分代可以是不连续的空间），将堆内存划分成一个个Region（1MB~32MB,   默认2048个分区）,这么做的目的是在进行收集时不必在全堆范围内进行。它主要特点在于达到可控的停顿时间，用户可以指定收集操作在多长时间内完成，即G1提供了接近实时的收集特性。它的步骤如下：

1. 初始标记（Initial Marking）：标记一下GC Roots能直接关联到的对象，伴随着一次普通的Young  GC发生，并修改NTAMS（Next Top at Mark  Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，此阶段是stop-the-world操作。
2. 根区间扫描，标记所有幸存者区间的对象引用，扫描 Survivor到老年代的引用，该阶段必须在下一次Young GC 发生前结束。
3. 并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行，该阶段可以被Young GC中断。
4. 最终标记（Final   Marking）：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered  Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered  Set中，此阶段是stop-the-world操作，使用snapshot-at-the-beginning (SATB) 算法。
5. 筛选回收（Live  Data Counting and  Evacuation）：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划,回收没有存活对象的Region并加入可用Region队列。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。

#### G1的特点

 G1 【分代收集、并发标记、区域回收、自适应调整】

1. 分代收集（Generational Collection）：
   G1垃圾回收器将堆内存划分为多个不同的区域，其中包括年轻代（Young Generation）和老年代（Old Generation）。年轻代用于存放新创建的对象，老年代用于存放存活时间较长的对象。G1使用分代收集策略，根据不同代的特点和回收需求采取不同的回收策略，提高垃圾回收的效率。
2. 并发标记（Concurrent Marking）：
   G1采用了并发标记的方式进行垃圾回收。在垃圾回收过程中，使用多CPU来缩短Stop-The-world的时间，G1会在后台线程中进行对象的标记，而不需要停止应用程序的执行。这样可以减少垃圾回收的停顿时间，提高应用程序的响应性能。
3. 区域回收（Region-Based Collection）：
   G1将堆内存划分为多个大小相等的区域，每个区域通常为1MB大小。G1会根据垃圾回收的需求，选择一部分区域进行回收。这种基于区域的回收方式可以使G1更加灵活地控制回收的范围，避免全堆回收带来的长时间停顿。G1从整体上来看是基于‘标记-整理’算法实现，从局部（相关的两块Region）上来看是基于‘复制’算法实现，这两种算法都不会产生内存空间碎片。
4. 自适应调整（Adaptive Sizing）：
   G1垃圾回收器具有自适应调整的能力，它可以根据实际的系统负载和垃圾回收的情况来动态地调整参数。例如，G1可以根据堆内存使用情况自动调整年轻代和老年代的大小，以及并发标记的触发时间等。这样可以更好地适应不同的应用场景和工作负载，提供更好的性能和垃圾回收效率。
5. 可预测的停顿：它可以自定义停顿时间模型，可以指定一段时间内消耗在垃圾回收商的时间不大于预期设定值。



#### 使用场景

G1 GC切分堆内存为多个区间（Region），从而避免很多GC操作在整个Java堆或者整个年轻代进行。G1  GC只关注你有没有存货对象，都会被回收并放入可用的Region队列。G1  GC是基于Region的GC，适用于大内存机器。即使内存很大，Region扫描，性能还是很高的。



### jvm调优

#### 死锁问题怎么排除

1. 使用jps查找运行的Java进程：jps -l
2. 使用jstack查看线程堆栈信息：jstack -l  进程id



#### CPU100%

1、所以先需要找出那个进程占用CPU高。

- top  列出系统各个进程的资源占用情况。

2、然后根据找到对应进行里哪个线程占用CPU高。

- top -Hp 进程ID  列出对应进程里面的线程占用资源情况

3、找到对应线程ID后，再打印出对应线程的堆栈信息

- printf "%x\n"  PID   把线程ID转换为16进制。
- jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为16进制的线程ID对应的线程信息。

4、最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。



#### 内存飙高问题怎么排查？

1、先观察垃圾回收的情况

- jstat -gc PID 1000 查看GC次数，时间等信息，每隔一秒打印一次。
- jmap -histo PID | head -20  查看堆内存占用空间最大的前20个对象类型,可初步查看是哪个对象占用了内存。

如果每次GC次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。

2、导出堆内存文件快照

- jmap -dump:live,format=b,file=/home/myheapdump.hprof PID  dump堆内存信息到文件。

3、使用jhat对dump文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。



#### 频繁fullgc

考虑创建对象过快或者内存太小或者内存泄漏

- 查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）
- 了解该时间点之前有没有程序上线、基础组件升级等情况。
- 了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。
- 再对步骤1中列出的可能原因做排除法，其中内存泄漏、代码显式调用gc方法比较容易排查。
- 针对大对象或者长生命周期对象，可通过 jmap命令并结合jhta分析dump堆内存文件作进一步分析，需要先定位到可疑对象。
- 通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。



#### 排查内存泄漏

1. 使用 `jps` 查看运行的 Java 进程 ID

2. 使用`top -p [pid]` 查看进程使用 CPU 和 MEM 的情况

3. 使用 `top -Hp [pid]` 查看进程下的所有线程占 CPU 和 MEM 的情况

4. 抓取线程栈：`jstack 29452 > 29452.txt`，可以多抓几次做个对比。

   在线程栈信息中找到对应线程号的 16 进制值，如下是 **731f** 线程的信息。线程栈分析可使用 Visualvm 插件 **TDA**。

5. 使用`jstat -gcutil [pid] 5000 10` 每隔 5 秒输出 GC 信息，输出 10 次，查看 **YGC** 和 **Full GC** 次数。

   或使用 `jmap -heap [pid]` 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。

6. 如果发现 `Full GC` 次数太多，就很大概率存在内存泄漏了

7. 使用 `jmap -histo:live [pid]` 输出每个类的对象数量，内存大小(字节单位)及全限定类名。

8. 生成 `dump` 文件，借助工具分析哪 个对象非常多，基本就能定位到问题在那了

9. 使用 **jhat** 命令分析：`jhat -port 8000 29471.dump`，



### 介绍下JVM

JVM（Java Virtual Machine，Java虚拟机）是 Java 程序的运行环境，它负责将 Java 字节码翻译成机器代码并执行。也就是说 Java 代码之所以能够运行，主要是依靠 JVM 来实现的。

JVM 整体的大概执行流程是这样的：

1. 程序在执行之前先要把 Java 代码转换成字节码（class 文件），JVM 首先需要把字节码通过一定的方式**类加载器** 把文件加载到内存中**运行时数据区**；运行时数据区包括

   方法区（Method Area）：用于存储已加载的类信息、静态变量、常量以及编译器优化后的代码等。它是各个线程共享的区域。

   堆（Heap）：用于存储对象实例和数组等动态分配的内存。所有通过关键字 `new` 创建的对象都存储在堆中，它也是各个线程共享的区域。

   栈（Stack）：每个线程都有自己的栈，用于存储局部变量、方法参数、返回地址等。栈中的数据是线程私有的，随着方法的调用和返回而动态地分配和释放。

   本地方法栈（Native Method Stack）：类似于栈，但是用于执行本地（Native）方法的数据区域。

   程序计数器（Program Counter Register）：用于存储当前线程执行的字节码指令的地址。每个线程都有自己的程序计数器，用于线程切换后恢复执行的位置。

​    2.但字节码文件是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器，也就是 JVM 的执行引擎会**将字节码翻译成底层系统指令再交由 CPU 去执行；**

​	3.**在执行的过程中，也需要调用其他语言的接口，如通过调用本地库接口来实现整个程序的运行，如下图所示：



### 什么是类加载器

类加载器（Class Loader）是 Java 虚拟机（JVM）的重要组成部分，负责将字节码文件加载到内存中并转换为可执行的类。

类加载总共分为以下四种：

1. **启动类加载器（Bootstrap Class Loader）**：它是 JVM 的内部组件，负责加载 Java 核心类库（如java.lang）和其他被系统类加载器所需要的类。启动类加载器是由 JVM 实现提供的，通常使用本地代码来实现。
2. **扩展类加载器（Extension Class Loader）**：它是 sun.misc.Launcher$ExtClassLoader 类的实例，负责加载 Java 的扩展类库（如 java.util、java.net）等。扩展类加载器通常从 java.ext.dirs 系统属性所指定的目录或 JDK 的扩展目录中加载类。
3. **系统类加载器（System Class Loader）**：也称为应用类加载器（Application Class Loader），它是sun.misc.Launcher$AppClassLoader 类的实例，负责加载应用程序的类。系统类加载器通常从 CLASSPATH 环境变量所指定的目录或 JVM 的类路径中加载类。
4. **用户自定义类加载器（User-defined Class Loader）**：这是开发人员根据需要自己实现的类加载器。用户自定义类加载器可以根据特定的加载策略和需求来加载类，例如从特定的网络位置、数据库或其他非传统来源加载类。

------



### 类加载过程

Java 中类加载总共分为以下 5 个步骤。

#### 1.加载

加载（Loading）：查找并加载类的二进制数据。这个过程可以通过类的全限定名来完成，也可以通过其他方式完成，比如使用 ClassLoader.loadClass() 方法。

在加载 Loading 阶段，Java 虚拟机需要完成以下 3 件事：

- 通过一个类的全限定名来获取定义此类的二进制字节流；
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
- 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

#### 2.验证

验证（Verification）：验证加载的类是否符合 Java 虚拟机规范，比如是否有正确的文件格式、是否有正确的访问权限等。

验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节 流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信 息被当作代码运行后不会危害虚拟机自身的安全。

验证选项：

- 文件格式验证
- 字节码验证
- 元数据验证
- 符号引用验证...

#### 3.准备

准备（Preparation）：为类的静态变量分配内存，并设置默认初始值。

准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。

比如此时有这样一行代码：

> public static int value = 123;

它是初始化 value 的 int 值为 0，而非 123。

#### 4.解析

解析（Resolution）：将类中的符号引用转换为直接引用，比如将类中的方法名转换为实际的内存地址。

解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程，也就是初始化常量的过程。

#### 5.初始化

初始化（Initialization）：执行类的初始化代码，包括静态变量赋值和静态代码块的执行。



### 双亲委派

双亲委派模型是 Java 类加载器的一种工作机制。

它是指当一个类加载器需要加载一个类时，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最 终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无 法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

双亲委派模型的优点是：

1. **避免重复加载类**：比如 A 类和 B 类都有一个父类 C 类，那么当 A 启动时就会将 C 类加载起来，那么在 B 类进行加载时就不需要在重复加载 C 类了。
2. **更安全**：使用双亲委派模型也可以保证了 Java 的核心 API 不被篡改，如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类，而有些 Object 类又是用户自己提供的因此安全性就不能得到保证了。

### 内存区域

1. **程序计数器（Program Counter Register）**：用于记录当前线程执行的字节码指令地址，是线程私有的，线程切换不会影响程序计数器的值。
2. **Java 虚拟机栈（Java Virtual Machine Stacks）**：用于存储方法执行时的局部变量表、操作数栈、动态链接、方法出口等信息，也是线程私有的。每个方法在执行时都会创建一个栈帧，栈帧包含了方法的局部变量表、操作数栈等信息。
3. **本地方法栈（Native Method Stack**）：与 Java 虚拟机栈类似，用于存储本地方法的信息。
4. **Java 堆（Java Heap）**：用于存储对象实例和数组，是 JVM 中最大的一块内存区域，它是所有线程共享的。堆通常被划分为年轻代和老年代，以支持垃圾回收机制。

   - **年轻代（Young Generation**）：用于存放新创建的对象。年轻代又分为 Eden 区和两个 Survivor 区（通常是一个 From 区和一个 To 区），对象首先被分配在 Eden 区，经过垃圾回收后存活的对象会被移到 Survivor 区，经过多次回收后仍然存活的对象会晋升到老年代。

   - **老年代（Old Generation）**：用于存放存活时间较长的对象。老年代主要存放长时间存活的对象或从年轻代晋升过来的对象。


1. **方法区（Methed Area**）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也是所有线程共享的。



### 为什么使用元空间代替永久代

之所以，使用元空间替代永久代，主要是因为官方需要将 HotSpot 虚拟机和 JRockit 融合，而 JRockit 虚拟机不存在永久代的概念，所以要去掉永久代的概念，除此之外使用元空间还可以提高稳定性、降低 OOM 以及节省运维成本。



### 内存溢出和内存泄漏的区别

内存溢出（Memory Overflow）和内存泄漏（Memory Leak）是两个与内存管理相关的问题，它们有以下区别：

1. 定义不同： 

   1. 内存溢出指的是在程序运行过程中申请的内存超出了可用内存资源的情况，导致无法继续分配所需的内存，从而引发异常。
   2. 内存泄漏指的是在程序中无意中保留了不再需要的对象引用，导致这些对象无法被垃圾回收机制回收，进而占用了不必要的内存空间。

2. 产生原因不同： 

   1. 内存溢出通常是由于程序运行时需要的内存超过了可用的内存资源，或者是存在大量占用内存的对象无法被及时释放。常见的内存溢出原因包括创建过多的对象、递归调用导致栈溢出等。
   2. 内存泄漏则是由于程序中存在不正确的对象引用管理，例如对象被误持有引用、缓存未清理等。

3. 影响不同： 

   1. 内存溢出会导致程序抛出 OutOfMemoryError 异常，程序无法继续执行。
   2. 内存泄漏则会导致内存资源的浪费，长时间运行下会导致可用内存逐渐减少，最终可能导致内存溢出。

4. 解决方案不同： 

   1. 对于内存溢出，可以通过增加可用内存、调整程序逻辑、优化资源使用等方式来解决。
5. 而对于内存泄漏，需要通过检查和修复对象引用管理问题，确保不再使用的对象能够被垃圾回收机制正确释放。



### 如何判断对象是否存活

在 JVM 中，判断对象是否存活的常见算法有以下两种：

1. 引用计数算法
2. 可达性分析算法

#### 1.引用计数器算法

引用计数器算法的实现思路是，给对象增加一个引用计数器，每当有一个地方引用它时，计数器就 +1；当引用失效时，计数器就 -1；任何时刻计数器为 0 的对象就是不能再被使用的，即对象已"死"。

**引用计数法的优点**：实现简单，判定效率也比较高。

**引用计数法的缺点**：是引用计数法无法解决对象的循环引用问题。

#### 2.可达性分析算法

可达性分析算法是通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称之为"引用链"，当一个对象到 GC Roots 没有任何的引用链相连时（从 GC Roots 到这个对象不可达）时，证明此对象是不可用的。

Java中的GC Roots对象：

- 虚拟机栈(栈帧中的局部变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象



### 垃圾回收算法

常见的垃圾回收算法有以下 4 个：

1. 标记-清除算法；
2. 复制算法；
3. 标记-整理算法；
4. 分代算法

#### 1.标记-清除算法

**标记-清除（Mark-Sweep）算法属于早期的垃圾回收算法，它是由标记阶段和清除阶段构成的。标记阶段会给所有的存活对象做上标记，而清除阶段会把没有被标记的死亡对象进行回收。**

**优点**：实现简单。

**缺点**：产生不连续的内存碎片，如果程序需要分配一个连续内存的大对象时，就需要提前触发一次垃圾回收。

#### 2.复制算法

**复制算法是将内存分为大小相同的两块区域，每次只使用其中的一块区域，这样在进行垃圾回收时就可以直接将存活的东西复制到新的内存上，然后再把另一块内存全部清理掉。**

**使用复制算法是可以解决内存碎片的问题的，但同时也带来了新的问题。因为需要将内存分为大小相同的两块内存，那么内存的实际可用量其实只有原来的一半，这样此算法导致了内存的可用率大幅降低了**。

**优点**：执行效率高，没有内存碎片的问题。

**缺点**：空间利用率低，因为复制算法每次只能使用一半的内存。

#### 3.标记整理

标记-整理算法是由两个阶段组成的：标记阶段和整理阶段。其中标记阶段和标记-清除算法的标记阶段一样，不同的是后面的一个阶段，标记-整理算法的后一个阶段不是直接对内存进行清除，而是把所有存活的对象移动到内存的一端，然后把另一端的所有死亡对象全部清除

**优点**：解决了内存碎片问题，比复制算法空间利用率高。

**缺点**：因为有局部对象移动，所以效率不是很高。

#### 4.分代收集

**分代算法并不能是某种具体的算法，而是一种策略，我们就姑且称它为分代算法吧。目前 HotSpot 虚拟机使用的就是此算法，在 HotSpot 虚拟机中将垃圾回收区域堆划分为两个模块：新生代和老生代

在分代算法中对于不同区域采用的具体算法也是不同的，新生代存放的大部分数据是朝生夕灭的，所以**新生代使用的是效率最高的复制算法；而老生代使用的是标记-清除或标记-整理算法，如果标记-清除可以满足需要那么就使用效率更好的标记-清除算法，如果标记-清除算法不能满足需要就使用标记-整理算法**



### JVM 常见的垃圾回收器

1. Serial 垃圾回收器：Serial是最基本的垃圾回收器，它以单线程方式进行垃圾回收。它会暂停所有应用线程，执行垃圾回收操作。Serial回收器适用于小型应用或者单核处理器环境。
2. ParNew：多线程的垃圾回收器（Serial 的多线程版本）；
3. Parallel 垃圾回收器：Parallel回收器也是一个单线程回收器，但它使用多线程并行执行垃圾回收操作。它能充分利用多核处理器的优势，提高垃圾回收的效率。Parallel回收器适用于多核处理器环境下的应用。
4. CMS（Concurrent Mark-Sweep）垃圾回收器：CMS回收器采用并发标记和清除的方式进行垃圾回收。它使用多线程并发标记活动对象，并在标记完成后，暂停应用线程进行清除操作。CMS回收器旨在减少垃圾回收导致的应用暂停时间，适用于低延迟要求的应用。
5. G1（Garbage-First）垃圾回收器：G1回收器是一种全局并发的垃圾回收器。它将堆划分为多个区域，并采用不同的回收策略来优化垃圾回收的效果。G1回收器可以根据应用的需求，动态地调整回收区域的大小和回收时间，以达到更平均的回收效果。



### Fullgc触发条件

Full GC（Full Garbage Collection）是指对整个堆内存进行垃圾回收的过程。在进行 Full GC 时，会对年轻代和老年代（以及永久代或元数据区）中的所有对象进行回收。

Full GC 通常发生在以下情况之一：

1. 显式触发：通过调用 System.gc() 方法显式触发垃圾回收。虽然调用该方法只是向 JVM 发出建议，但在某些情况下，JVM 可能会选择执行 Full GC。
2. 老年代空间不足：当老年代空间不足时，无法进行对象的分配，会触发 Full GC。此时，Full GC 的目标是回收老年代中的无效对象，以释放空间供新的对象分配。
3. 永久代或元数据区空间不足：在使用永久代（Java 8 之前）或元数据区（Java 8 及之后）存储类的元数据信息时，如果空间不足，会触发 Full GC

