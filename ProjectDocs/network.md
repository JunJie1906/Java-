# TCP/IP

TCP/IP协议它是一组用于实现互联网通信的协议，目的是为了实现不同计算机和网络之间的通信。

TCP/IP 协议包括两个部分：传输控制协议（TCP）和互联网协议（IP）。IP 协议负责数据包在网络中的传输，而TCP协议则负责在数据传输过程中对数据的可靠性进行保证，确保数据能够被正确地传输到目的地。

## 常见应用

TCP/IP 协议是互联网通信的基础协议，它广泛应用于各种计算机网络和应用程序中，下面是一些常见的应用：

1. Web 浏览器：Web 浏览器使用 HTTP 协议和 TCP/IP 协议进行通信，通过 Internet 将 Web 页面从 Web 服务器传输到用户的计算机上。
2. 电子邮件：电子邮件客户端使用 SMTP 协议和 TCP/IP 协议将电子邮件发送到邮件服务器，并使用 POP 或 IMAP 协议从邮件服务器上接收邮件。
3. 文件传输：FTP 客户端使用 FTP 协议和 TCP/IP 协议将文件从 FTP 服务器传输到本地计算机上，或将文件从本地计算机上传到 FTP 服务器上。
4. 远程登录：远程登录客户端使用 Telnet 协议和 TCP/IP 协议远程登录到远程服务器上执行命令和操作。
5. 实时音视频通信：实时音视频通信应用程序使用 RTP 和 RTCP 协议和 TCP/IP 协议进行通信，例如 Skype、Zoom、微信等。
6. 网络游戏：网络游戏客户端使用 TCP/IP 协议与游戏服务器通信，通过 Internet 进行游戏数据的传输和处理。
7. 云计算：云计算平台使用 TCP/IP 协议将计算资源从云服务器传输到用户的计算机上，提供云计算服务和资源

## TCP/IP分层

TCP/IP 协议是一种分层协议，将网络通信的功能分成了五个层次，分别是：物理层、数据链路层、网络层、传输层和应用层(自下而上)。每个层次都有自己的任务和责任，通过不同层次之间的协调和合作，实现了计算机之间的数据传输。 

1. 物理层：物理层是网络通信的最底层，主要负责将数字信号转换成物理信号，例如电信号、光信号等，然后通过物理介质（例如电缆、光纤等）进行传输。
2. 数据链路层：数据链路层负责将物理层传输的数据进行分帧和差错检测，确保数据的可靠传输，同时也负责寻址和流量控制等功能。
3. 网络层：网络层主要负责数据的路由和转发，将数据包从源主机传输到目标主机。在路由选择方面，网络层采用了一些算法和协议，例如IP协议和路由选择协议等。
4. 传输层：传输层主要负责数据传输的可靠性和数据流量的控制。TCP协议是传输层协议的一种，它能够保证数据传输的可靠性，并且通过拥塞控制等机制，保证了网络流量的合理分配。
5. 应用层：应用层是网络通信的最高层，它负责实现应用程序之间的通信。常见的应用层协议包括HTTP、FTP、SMTP等，它们提供了数据交换的标准格式和规范，使得不同操作系统和应用程序之间能够进行数据的交换和共享。

# 应用层常见协议

应用层是 TCP/IP 协议体系结构中的最高层，它定义了应用程序与网络之间的接口协议，常见的应用层协议有：

1. HTTP：超文本传输协议，用于 Web 服务器和 Web 浏览器之间的数据交换，是 Web 通信的基础协议。
2. FTP：文件传输协议，用于在客户端和服务器之间传输文件，支持上传、下载、删除等操作。
3. SMTP：简单邮件传输协议，用于在邮件客户端和邮件服务器之间传输邮件，支持发送邮件和接收邮件。
4. POP3：邮局协议版本3，用于在邮件客户端和邮件服务器之间接收邮件，支持邮件下载、存储和删除等操作。
5. IMAP：互联网消息访问协议，与 POP3 类似，但支持在服务器上管理邮件，并允许用户在多个设备上同步邮件。
6. DNS：域名系统，用于将域名转换成IP地址，使得用户可以通过易于记忆的域名来访问 Web 站点等。
7. DHCP：动态主机配置协议，用于自动分配 IP 地址和其他网络配置信息，使得用户可以方便地连接到网络上。
8. Telnet：远程终端协议，用于在客户端和服务器之间建立远程连接，允许用户在远程计算机上执行命令和操作。
9. SSH：安全外壳协议，与 Telnet 类似，但提供加密和安全认证功能，保护用户的数据和隐私。
10. SNMP：简单网络管理协议，用于网络设备管理和监控，允许管理员监控网络设备的状态和性能。

## 输入url后发生了什么

大致流程：
URL 解析 --> DNS 查询 --> TCP 连接 --> 处理请求 --> 接受响应 --> 渲染页面

### 一. URL 解析

**地址解析：**

首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。

**HSTS:**

由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：你所不知道的 HSTS。

**其他操作:**

浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。

**检查缓存:**
![img.png](计算机网络常考/img.png)

### 二. DNS 查询

![img.png](计算机网络常考/dasd.png)
**1. 浏览器缓存**

浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。

**2. 操作系统缓存**

操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。

**3. 路由器缓存**

路由器也有自己的缓存。

**4. ISP DNS 缓存**

ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。

**5. 根域名服务器查询**

在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：
![img.png](计算机网络常考/fafd.png)
**需要注意的点**

1. 递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）
2. 迭代方式，就是本地DNS服务器到根域名服务器查询的方式。
3. 什么是 DNS 劫持
4. 前端 dns-prefetch 优化

### 三、TCP 连接

TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：
![img.png](计算机网络常考/asdf.png)
**1. 应用层：发送 HTTP 请求**
   在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：

* 请求报头（Request Header）：请求方法、目标地址、遵循的协议等等
* 请求主体（其他参数）

其中需要注意的点：

* 浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法

**2. 传输层：TCP 传输报文**
   传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。

在建立连接前，会先进行 TCP 三次握手。

可能出现SYN泛洪攻击：https://zhuanlan.zhihu.com/p/632649858


**3. 网络层：IP协议查询Mac地址**
   将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。

判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。

**注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。**

**4. 链路层：以太网协议**

根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：

* 标头：数据包的发送者、接受者、数据类型
* 数据：数据包具体内容

**Mac 地址**

以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。

**广播**

发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。

注意：接收方回应是单播。

可能出现ARP攻击：https://zhuanlan.zhihu.com/p/153317884

**服务器接受请求**

接受过程就是把以上步骤逆转过来

#### TCP连接三次握手

##### 一、TCP包首部：

网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。
![img.png](计算机网络常考/cfaewfda.png)
TCP首部承载这TCP协议需要的各项信息，下面我们来分析一下：

**TCP端口号：**

TCP的连接是需要四个要素确定唯一一个连接：
（源IP，源端口号）+ （目地IP，目的端口号）
所以TCP首部预留了两个16位作为端口号的存储，而IP地址由上一层IP协议负责传递
源端口号和目地端口各占16位两个字节，也就是端口的范围是2^16=65535
另外1024以下是系统保留的，从1024-65535是用户使用的端口范围

**TCP的序号和确认号：**

1. 32位序号 seq：Sequence number 缩写seq ，TCP通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据有序，比如现在序列号为1000，发送了1000，下一个序列号就是2000。 
2. 32位确认号 ack：Acknowledge number 缩写ack，TCP对上一次seq序号做出的确认号，用来响应TCP报文段，给收到的TCP报文段的序号seq加1。

**TCP的标志位**

每个TCP段都有一个目的，这是借助于TCP标志位选项来确定的，允许发送方或接收方指定哪些标志应该被使用，以便段被另一端正确处理。
用的最广泛的标志是 **SYN，ACK 和 FIN**，用于建立连接，确认成功的段传输，最后终止连接。

1. SYN：简写为S，同步标志位，用于建立会话连接，同步序列号； 
2. ACK： 简写为.，确认标志位，对已接收的数据包进行确认； 
3. FIN： 简写为F，完成标志位，表示我已经没有数据要发送了，即将关闭连接； 
4. PSH：简写为P，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；
5. RST：简写为R，重置标志位，用于连接复位、拒绝错误和非法的数据包； 
6. URG：简写为U，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理

##### 二、 TCP 三次握手建立连接 

三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。
![img.png](计算机网络常考/cwerfqwfdeq.png)

* **第一次握手：**
  客户端将TCP报文标志位SYN置为1，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入SYN_SENT状态，等待服务器端确认。

* **第二次握手：**
  服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。

* **第三次握手：**
  客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

注意:我们上面写的ack和ACK，不是同一个概念：

* 小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，ack=seq+1。
* 大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1

**TCP 第三次握手能携带数据吗？**
第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手 不可以携带数据。

这是因为：第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。

**为什么要三次握手**

TCP 协议在建立连接时采用三次握手的方式，主要是为了确保客户端和服务器之间建立起可靠的连接。 TCP 之所以需要 3 次握手是因为 TCP 双方都是全双工的。所谓全双工指的是，TCP 任何一端既是发送数据方，又是接收数据方，因此这就要求 TCP 通讯双方既要保证自己的发送能力，又要保证自己的接收能力才行。
就像两个人打电话一样。

### 四、服务器处理请求

大致流程：
![img.png](计算机网络常考/fqfdwqexcaq.png)
**HTTPD**

最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。
它会监听得到的请求，然后开启一个子进程去处理这个请求。

**处理请求**

接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：

* 验证是否配置虚拟主机 
* 验证虚拟主机是否接受此方法 
* 验证该用户可以使用该方法（根据 IP 地址、身份信息等）

**重定向**

假如服务器配置了 HTTP 重定向，就会返回一个 301永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。

**URL 重写**

然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。

否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。

然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。

### 五、浏览器接受响应

浏览器接收到来自服务器的响应资源后，会对资源进行分析。

首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。

如果响应资源进行了压缩（比如 gzip），还需要进行解压。

然后，对响应资源做缓存。

接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。

### 六、渲染页面

## DNS 执行流程

DNS 域名解析的大致流程如下：

1. 先检查浏览器中的 DNS 缓存，如果浏览器中有对应的记录会直接使用，并完成解析；
2. 如果浏览器没有缓存，那就去查询操作系统的缓存，如果查询到记录就可以直接返回 IP 地址，完成解析；
3. 如果操作系统没有 DNS 缓存，就会去查看本地 host 文件，Windows 操作系统下，host 文件一般位于 "C:\Windows\System32\drivers\etc\hosts"，如果 host 文件有记录则直接使用；
4. 如果本地 host 文件没有相应的记录，会请求本地 DNS 服务器，本地 DNS 服务器一般是由本地网络服务商如移动、电信提供。通常情况下可通过 DHCP 自动分配，当然你也可以自己手动配置。目前用的比较多的是谷歌提供的公用 DNS 是 8.8.8.8 和国内的公用 DNS 是 114.114.114.114。
5. 如果本地 DNS 服务器没有相应的记录，就会去根域名服务器查询了，目前全球一共有 13 组根域名服务器（这里并不是指 13 台服务器，是指 13 个 ip 地址，按字母 a-m 编号），为了能更高效完成全球所有域名的解析请求，根域名服务器本身并不会直接去解析域名，而是会把不同的解析请求分配给下面的其他服务器去完成，下面是 DNS 域名系统的树状结构图：
   ![img.png](计算机网络常考/vadscdadscdas.png)

# GET 和 POST 的区别

GET 请求和 POST 请求是 HTTP 协议中最常用的两种请求方法。但它们在数据传输方式、传输数据的大小和安全性等方面有所不同

1. 数据传输方式：GET 请求的数据是通过 URL 传递的，即将数据拼接到 URL 的后面，以 ? 分隔，参数之间以 & 符号分隔。因此， GET 请求对于传输的数据大小是有限制的，通常在几千个字符之内。而 POST 请求则是将数据放在 HTTP 请求的请求体中进行传输，没有大小限制，可传输较大的数据量。
2. 数据传输安全性：GET 请求传输的数据是明文的，因此数据容易被拦截和篡改。而 POST 请求传输的数据放在请求体中，所以相对安全一些。
3. 缓存：GET 请求是可以被缓存的，当浏览器再次请求同一个 URL 时，可以从缓存中直接获取数据，加快访问速度。而 POST 请求是不可缓存的，因为每次提交数据都可能导致服务器状态的改变。
4. 安全性：GET 请求的数据会被浏览器保存在历史记录和服务器日志中，容易被恶意程序利用。而 POST 请求不会被保存在历史记录和服务器日志中，相对更加安全。

# 转发重定向和请求重定向的区别

## 1.定义不同

**请求转发（Forward）：发生在服务端程序内部，当服务器端收到一个客户端的请求之后，会先将请求，转发给目标地址，再将目标地址返回的结果转发给客户端。** 而客户端对于这一切毫无感知的，这就好比，张三（客户端）找李四（服务器端）借钱，而李四没钱，于是李四又去王五那借钱，并把钱借给了张三，整个过程中张三只借了一次款，剩下的事情都是李四完成的，这就是请求转发。

**请求重定向（Redirect）：请求重定向指的是服务器端接收到客户端的请求之后，会给客户端返回了一个临时响应头，这个临时响应头中记录了，客户端需要再次发送请求（重定向）的 URL 地址，客户端再收到了地址之后，会将请求发送到新的地址上，这就是请求重定向。** 这就好像张三（客户端）找李四（服务器端）借钱，李四没钱，于是李四就告诉张三，“我没钱，你去王五那借“，于是张三又去王五家借到了钱，这就是请求重定向。

## 2.请求方不同

从上面请求转发和请求重定向的定义，我们可以看出：请求转发是服务器端的行为，服务器端代替客户端发送请求，并将结果返回给客户端；而请求重定向是客户端的行为
![img.png](计算机网络常考/dsacacdas.png)

## 3.数据共享不同

请求转发是服务器端实现的，所以整个执行流程中，客户端（浏览器端）只需要发送一次请求，因此整个交互过程中使用的都是同一个 Request 请求对象和一个 Response 响应对象，所以整个请求过程中，请求和返回的数据是共享的；而请求重定向客户端发送两次完全不同的请求，所以两次请求中的数据是不同的。

## 4.最终 URL 地址不同

请求转发是服务器端代为请求，再将结果返回给客户端的，所以整个请求的过程中 URL 地址是不变的；而请求重定向是服务器端告诉客户端，“你去另一个地访问去”，所以浏览器会重新再发送一次请求，因此客户端最终显示的 URL 也为最终跳转的地址，而非刚开始请求的地址，所以 URL 地址发生了改变。

## 5.代码实现不同

```java
// 请求转发的实现代码如下：
@RequestMapping("/fw")
public void forward(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.getRequestDispatcher("/index.html").forward(request, response);
        }

```

```java
// 请求重定向的实现代码如下：
@RequestMapping("/rt")
public void redirect(HttpServletRequest request, HttpServletResponse response) throws IOException {
        response.sendRedirect("/index.html");
        }
```

# TCP 四次挥手

**四次挥手的具体流程如下**：

1. 客户端发送 FIN 包：客户端发送一个 FIN 包，其中 FIN 标识位为 1，表示客户端希望关闭连接。
2. 服务器发送 ACK 包：服务器收到客户端的 FIN 包后，向客户端发送一个 ACK 包，其中 ACK 标识位为 1，表示服务器已经收到了客户端的请求，并将确认号设置为客户端发送的序列号+1。
3. 服务器发送 FIN 包：服务器在发送完 ACK 包之后，也会发送一个 FIN 包，其中 FIN 标识位为 1，表示服务器也希望关闭连接。
4. 客户端发送 ACK 包：客户端收到服务器的 FIN 包后，向服务器发送一个 ACK 包，其中 ACK 标识位为 1，表示客户端已经收到了服务器的请求，并将确认号设置为服务器发送的序列号+1。

![img.png](计算机网络常考/efgqcqwce.png)

## 主要作用

1. 确保所有数据都被传输完成：在关闭连接前，双方都可能还有数据需要传输，因此需要四次挥手来确保所有数据都被传输完成。
2. 避免服务器收到来自已关闭的连接的数据：在关闭连接后，服务器可能会收到来自已关闭的连接的数据，因此需要等待一段时间，确保客户端收到了服务器的 FIN 包并确认关闭连接，才能关闭连接。
3. 确保双方都能正确地关闭连接：四次挥手的过程中，客户端和服务器都需要发送 FIN 和 ACK 包，以确保双方都能正确地关闭连接，避免连接一方关闭而另一方仍然处于连接状态。

因此，TCP 协议需要进行四次挥手，以确保双方都能正确地关闭连接，并避免数据的丢失和混淆。

## tcp四次挥手为什么不能是三次

由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接

通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。

举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。

# TCP 和 UDP 的区别

TCP 和 UDP 都是传输层的重要协议，它们都是用来将数据从源主机发送到目标主机的，但它们存在以下几点不同：

1. 连接机制不同：TCP 是面向连接的协议，需要在客户端和服务器之间建立一个稳定的连接，然后再进行数据传输；而 UDP 是无连接的协议，数据包可以直接发送给目标主机，不需要事先建立连接。
2. 数据传输方式不同：TCP 采用可靠的数据传输方式，即在传输过程中使用序号、确认号和重传机制等控制手段来保证数据的可靠传输；而 UDP 采用不可靠的数据传输方式，数据包可能会丢失或重复，不提供数据可靠性保障。
3. 数据传输效率不同：由于 TCP 需要进行连接、序号确认等额外的数据包传输，因此在数据传输效率方面相对于 UDP 要低一些。
4. 数据大小限制不同：UDP 对数据包的大小有限制，最大只能传输 64KB 的数据，而 TCP 的数据包大小没有限制。
5. 应用场景不同：TCP 适用于要求数据传输可靠性高的场景，如网页浏览、文件下载、电子邮件等；而 UDP 适用于实时性要求较高的场景，如视频会议、在线游戏等。

#常用的HTTP状态码

## 消息状态码

* **100：Continue 继续。客户端应继续其请求。**
* 101：Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议

## 成功状态码

* **200：OK 请求成功。一般用于 GET 与 POST 请求。**
* 201：Created 已创建。成功请求并创建了新的资源。
* 202：Accepted 已接受。已经接受请求，但未处理完成。
* 203：Non-Authoritative Information 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本。
* 204：No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。
* 205：Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域。
* 206：Partial Content 部分内容。服务器成功处理了部分 GET 请求

## 重定向状态码

* 300：Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。
* **301：Moved Permanently 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替。**
* **302：Found 临时移动，与 301 类似。但资源只是临时被移动。客户端应继续使用原有URI。**

## 客户端错误状态码

* 400：Bad Request 客户端请求的语法错误，服务器无法理解。
* 401：Unauthorized 请求要求用户的身份认证。
* 402：Payment Required 保留，将来使用。
* 403：Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求。
* **404：Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面。**
* **405：Method Not Allowed 客户端请求中的方法被禁止。**

## 服务端错误状态码

* **500：Internal Server Error 服务器内部错误，无法完成请求。**
* **501：Not Implemented 服务器不支持请求的功能，无法完成请求。**
* **502：Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。**
* 503：Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中

# 什么是 HTTPS

HTTPS（Hyper Text Transfer Protocol Secure，安全的超文本传输协议）是一种基于 SSL/TLS 协议的 HTTP 协议，它是 HTTP 协议的安全版本。HTTPS 协议通过加密通信内容和身份验证来保证数据传输的安全性和完整性，从而可以有效地防止数据在传输过程中被窃取或篡改

## SSL 和 TLS

SSL（Secure Socket Layer）：安全套节层协议。 
TLS（Transport Layer Security）：传输层安全协议。 

SSL（Secure Socket Layer）最早是由浏览器开发厂商网景公司开发的，此公司开发了 SSL 3.0 及 3.0 之前的版本，之后便将 SSL 交给了 IETF（Internet Engineering Task Force）Internet 工程任务组的手中，IETF 以 SSL 3.0 为基础开发了 TLS 1.0，所以可以认为 TLS 是 SSL 的“新版本”。

## HTTPS VS HTTP

HTTPS 协议与 HTTP 协议的区别在于，HTTPS 协议在数据传输过程中使用了 SSL/TLS 协议进行加密和身份验证，另外关于它们两个的默认端口号也是不同的，HTTP 的默认端口号是 80，而 HTTPS 的默认端口号是 443。

## HTTPS执行流程

### HTTPS 执行流程如下：

1. 客户端使用 HTTPS 访问服务器端。
2. 服务器端返回数字证书，以及使用非对称加密，生成一个公钥给客户端（私钥服务器端自己保留）。
3. 客户端验证数字证书是否有效，如果无效，终止访问，如果有效： 

* 使用对称加密（概念见最下方）生成一个共享秘钥；
* 使用对称加密的共享秘钥加密数据；
* 使用非对称加密的公钥加密（对称加密生成的）共享秘钥；
* 发送加密后的秘钥和数据给服务器端。

4. 服务器端使用私钥解密出客户端（使用对称加密生成的）共享秘钥，再使用共享秘钥解密出数据的具体内容。
5. 之后客户端和服务器端就使用共享秘钥加密的内容内容进行交互了。

### 常见的加密算法

* 对称加密：使用相同的密钥进行加密和解密的算法。发送方和接收方必须共享密钥才能进行通信，这使得对称加密算法在保密性和性能方面非常高效。常见的对称加密算法包括 AES（高级加密标准）和 DES（数据加密标准）。
* 非对称加密：也称为公钥加密，使用一对密钥，即公钥和私钥。发送方使用接收方的公钥进行加密，而接收方使用其私钥进行解密。非对称加密算法可以实现加密和数字签名等功能。常见的非对称加密算法包括 RSA 和 ECC（椭圆曲线加密）。
* 哈希函数：也称为散列函数，将任意长度的输入数据映射为固定长度的输出值（哈希值）。哈希函数通常用于验证数据的完整性，常见的哈希函数包括 MD5、SHA-1、SHA-256 等。哈希函数是不可逆的，即无法从哈希值还原出原始输入

### 为什么HTTPS同时使用两种加密？

HTTPS 第一次使用的是非对称加密，之后使用对称加密，其原因是，第一次要保证通讯安全，所以非对称加密是最好的选择，而之后，因为已经建立了安全通讯，并且后面传输数据也要考虑通讯的效率问题，所以使用对称加密，及兼顾安全（对称加密秘钥使用非对称加密来保证）同时效率又高